function buildTRNs_mLassoFit(fitOutMat,tfaMat,priorMergedTfsFile,bootCut,nboot,...
    parallel, rankMethod , bootsHistPdf, trnOutMat,outNetFileSparse,selectionMethod,...
    alpha)
%% GOAL: Rank TF-gene interactions according to confidence:
%           1 - var(residuals_i)/var(residuals [~TF]). 
%   If outNetFileSparse (file name) is supplied, this fxn will output the TRN 
%   in "sparse" format : TF, target gene, edge weight + additional edge metadata for
%   viewing with jp_gene_viz) as well as a .mat file summary file
%% Reference:
% Miraldi et al. "Leveraging chromatin accessibility data for 
%   transcriptional regulatory network inference in T Helper 17 Cells"
% MTL paper
%% Author: Emily R. Miraldi, Ph.D., Divisions of Immunobiology and Biomedical
%   Informatics, Cincinnati Children's Hospital
% Peter DeWeirdt, Intern, Divisions of Immunobiology and Biomedical
%   Informatics, Cincinnati Children's Hospital
%% INPUTS:
% fitOutMat -- contains network- and gene-level fit,
%   lambdaRange
% tfaMat -- a .mat file containing the prior of TF-gene interactions as
%   well as TFA (prior-based and TF mRNA), e.g., as generated by 
%   integratePrior_estTFA.m
% priorMergedTfsFile -- if degenerate TFs were merged (e.g., by
%   mergeDegeneratePriorTFs.py in priorParsingFunctions) to enable
%   prior-based TFA calculation, supply the two-column, tab-delimited file,
%   where column 1 = merged TF names as in the merged TF prior, and column
%   2 = individual TF names, separated by ", " e.g., as in
%   Th17_example/inputs/priors/ATAC_allTh_mergedTfs.txt:
%         Mesp1_Mesp2     Mesp1, Mesp2
%         Npas1_Npas3...  Npas1, Npas3, Sim1, Sim2
%         Nr1h2_Nr1h3     Nr1h2, Nr1h3   
%   NOTE: provide an empty string '' if there were no degenerate TFs in the
%   prior, this file does not exist, or TF mRNA was used for TFA
% bootCut -- Cutoff for how many bootstraps to include an edge in the final model [0,1] 
% nboot -- Number of bootstrap samples
% rankmethod -- 'rank' or 'confidence'
% bootHistPdf -- a filename to be used for generating a histogram of
%   nonzero edge subsample frequencies at the target instability cutoff.  
%   NOTE: empty string '' signals not to create this output
% trnOutMat -- name for output .mat containing ranks, confidence,
%   etc., for downstream analysis (e.g., gene expression prediction)
% outNetFileSparse -- name for tab-delimited network file in "sparse" format (i.e., 
%   first three columns are TF, gene, and signed confidence + metadata,
%   including metadata to modulate edge color and other features in
%   visualization tool jp_gene_viz
%   (https://github.com/simonsfoundation/jp_gene_viz), NOTE: empty string
%   '' signals not to create this output
% selectionMethod -- Whether to select parameters using network or per gene
% fit
%% OUTPUTS:
%% ${outDir}/Results_lassoFit/${quantNetFolderName} outputs:
% trnOutMat -- contains ranked lists of network edges, confidences,
%   whether they were in the input prior, etc.
% outNetFileSparse -- (optional) 3-column network file format for visualization in 
%       jp_gene_viz, edges that are in more than bootCut fraction of
%       bootstraps are included in the final model. 
%        0.  Edge confidence is calculated as:
%               1 - var(residuals_i)/var(residuals [~TF])
%        1.  Edge thickness (in output sparse network) is proportional to 
%              rank combine value 
%        2.  Edges signs are calculated based on glmnet results

load(tfaMat)
load(fitOutMat)
inPriorMat = sign(abs(priorMat));  

%% Calculate confidences and ranks for nbootstraps, plot results
options = glmnetSet;
options.alpha = alpha;
if strcmp(selectionMethod, 'network')   
    [~, optInd] = within1seMin(netFit);
    optLam = lambdaRange(optInd);
    options.lambda = optLam;
end
if parallel
    opt = statset('UseParallel', true);
else 
    opt = statset('UseParallel', false);
end

if strcmp(selectionMethod, 'network')  
    boot_confs_rnks_sgns = bootstrp(nboot, @(x, Ys) getConfs(x', Ys', priorWeightsMat,...
        options, selectionMethod),predictorMat', responseMat', 'Options', opt);
else strcmp(selectionMethod, 'gene')  
    boot_confs_rnks_sgns = bootstrp(nboot, @(x, Ys) getConfs(x', Ys', priorWeightsMat,...
        options,selectionMethod, geneFit, lambdaRange),predictorMat',...
        responseMat', 'Options', opt);
end
confs = boot_confs_rnks_sgns(:,1); % Each of these is nboots x nGenes x nTFs 
rnks = boot_confs_rnks_sgns(:,2);
sgns = boot_confs_rnks_sgns(:,3);

%% Plot a histogram of the mean TFs/gene in each bootstrap sample
mean_TFsGene = cellfun(@(C) mean(sum(abs(C'))), sgns);
figure(4), clf
subplot(2,1,1)
set(0, 'defaultAxesFontSize', 14);
histogram(mean_TFsGene)
xlabel('Mean TFs/Gene')
ylabel('Count')
title(strcat(['Sparsity for ' num2str(nboot) ' Bootstraps (no cutoff)']))
grid on 
axis tight


%% Rank edges based on confidence scores and ranks
disp('Ranking Edges')
confsMat = cat(3, confs{:});
rnksMat = cat(3, rnks{:});
sgnsMat = cat(3, sgns{:});
posCombine = sum(abs(sgnsMat), 3); % How many bootstraps was the sample in?
signCombine = sign(sum(sgnsMat, 3));
rankCombine = sum(rnksMat, 3);
normRankCombine = rankCombine/max(rankCombine(:));
confCombine = sum(confsMat, 3);
normConfCombine = confCombine/max(confCombine(:));
% nRemoved = length(find(normRankCombine)) - length(find(signCombine));
% disp(['Removing ' num2str(nRemoved) ' edges because bootstraps could not reach a consensus on sign.'])
% signRankCombine = normRankCombine.*signCombine;
% signConfCombine = normConfCombine.*signCombine;
% scatter(signRankCombine(keepRankings), signConfCombine(keepRankings));
% xlabel('Rank Combine')
% ylabel('Confidene Combine')

%% only keep nonzero rankings
inPriorVec = inPriorMat(:);
totNetTfs = length(allPredictors);
totNetGenes = length(targGenes);
totInts = totNetGenes * totNetTfs;   
targs = repmat(targGenes',totNetTfs,1); % Melting for two column format
regs1 = repmat(allPredictors',totNetGenes,1);
regs = reshape(regs1,totInts,1);

if strcmp(rankMethod,'rank')
    rankings = normRankCombine;
elseif strcmp(rankMethod,'confidence')
    rankings = normConfCombine;
else
    disp('Ranking method not yet supported.')
    return
end
keepRankings = find(abs(posCombine.*signCombine) > bootCut*nboot); %Remove all edges that have no sign consensus and are in less tha    
keepRankingsSgns = zeros(size(rankings));
keepRankingsSgns(keepRankings) = sgnsMat(keepRankings);
%% Plot edges per gene in the final network
tfsPerGene = sum(abs(keepRankingsSgns),2);
subplot(2,1,2)
histogram(tfsPerGene)
xlabel('TFs/Gene')
ylabel('Count')
title(strcat(['Sparsity for Optimal Network (' num2str(bootCut) ' cutoff)']))
grid on 
axis tight

if bootsHistPdf
    figName = bootsHistPdf;
    saveas(gcf,figName,'fig')
    fp = fillPage(gcf, 'margins', [0 0 0 0], 'papersize', [7 6]);
    print('-painters','-dpdf','-r150',[figName '.pdf'])
    disp(figName)
end

[vals, inds] = sort(abs(rankings(keepRankings)),'descend');
% update info sources
rankings = rankings(keepRankings(inds));    
regs = {regs{keepRankings(inds)}}';
targs = {targs{keepRankings(inds)}}';
totInfInts = length(rankings);
if strcmp(rankMethod,'rank')
    rankings2 = normConfCombine;
    rank2 = 'confidence';
elseif strcmp(rankMethod,'confidence')
    rankings2 = normRankCombine;
    rank2 = 'rank';
end
rankings2 = rankings2(keepRankings(inds));




if outNetFileSparse
    %% Network Edge colors, for jp_gene_viz
    disp('Writing out Net File')
    medBlue = [0,85,255];
    medRed = [228,26,28];
    lightGrey = [217,217,217];

    %% output meanEdgesPerGene "Quantile" network in sparse network format
    fout = fopen(outNetFileSparse,'w');
    
    fprintf(fout,strcat(['TF\tTarget\t' rankMethod '\t' rank2 '\tstroke\tstroke-width\tstroke-dasharray\n']));
    % For network visualization in jp_gene_viz (on Github):
    % Stroke -- denotes color in R,G,B format? -- current "stroke" only
    %   accepts color names, so have capital Stroke until R,G,B is
    %   recognized by "stroke"
    % stroke-width will go from [1,2] and will be proportional to
    % rankMethod
    % stroke-dash-array will incorporate prior information:
    % None --> will be solid and is for Prior-supported edges
    % 2,2 --> will be for edges Not supported by the prior    
    minRank = min(rankings); maxRank = max(rankings); rrange = maxRank-minRank;

    for ii = 1:totInfInts
        strokeWidth = 1 + (rankings(ii)-minRank)/rrange;  % 
        currRank2 = rankings2(ii);
        if currRank2 >= 0
            strokeVals = cellstr(num2str(round([currRank2*medRed + (1-currRank2)*lightGrey]')));
        else            
            strokeVals = cellstr(num2str(round([-currRank2*medBlue + (1+currRank2)*lightGrey]')));
        end
        stroke = ['rgb(' strjoin(strokeVals,',') ')'];
        if inPriorVec(ii) % solid line for thing in the prior (jp_gene_viz)
            fprintf(fout,[regs{ii} '\t' targs{ii} '\t' num2str(rankings(ii)) ...
                '\t' num2str(currRank2)...
                '\t' stroke ...
                '\t' num2str(strokeWidth) '\tNone\n']);
        else % dotted line for things not in the prior
            fprintf(fout,[regs{ii} '\t' targs{ii} '\t' num2str(rankings(ii)) ...
                '\t' num2str(currRank2)...
                '\t' stroke ...
                '\t' num2str(strokeWidth) '\t2,2\n']);
        end
    end
    fclose(fout);
    disp(outNetFileSparse)

end

%% save results
disp('saving_results')
outMat = [strrep(trnOutMat,'.mat','') '.mat'];
save(outMat,... 
    'predictorMat',... % include predictorMat
    'responseMat',... % responseMat so partial correlations can be calculated anew later, if needed
    'inPriorMat',...
    'targGenes',...
    'allPredictors',...
    'regs',...
    'targs',...
    'rankings',...
    'rankings2',...
    'inPriorVec')                
disp(outMat)

